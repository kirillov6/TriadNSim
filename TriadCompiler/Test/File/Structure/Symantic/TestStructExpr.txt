structure Str[integer a]
def	
	
	(*Объявление вершин*)
	Str := node P;
	Str := node P<L>;
	Str := node P[10]<L>;
	Str := node P[10]<L[10]>;
	Str := node P[10]<L[10], L, L[10]>;
	Str := node P[0:9,0]<L[10,10:10], L, L[10]>;
	
	(*Размерность массивов может задаваться переменной*)
	Str := node P[a + 10, a]<L[a + 10 : a]>;
		
	(*Тип индекса должен быть целым*)
	$155,155,155,155
	Str := node P[1.2]<L[1.2]> + node P[1 : 1.2]<L[1 : 1.2]>;
	
	(*Если индекс задан константой, то она должна быть неотрицательной*)
	$169,169
	Str := node P[-1:-1] + node P[0:0] + node P[1];
	$169,169
	Str := node P<L[-1:-1]> + node P<L[0:0]> + node P<L[1]>;
	
	Str := node P[0:0,0:10,10]<L,L[0:0,0:10,10]>;
	
	(*Верхний индекс диапазона не может быть меньше нижнего*)
	$320,320
	Str := node P[1:0]<Q[1:0]>;
	
	(*Объявление дуг и ребер*)
	Str := arc ( D.F -- G.D );	
	Str := arc ( D[10].F -- G.D[10] );
	Str := arc ( D.F[10] -- G[10].D );
	Str := arc ( D[10].F[10] -- G[10].D[10] );
	Str := edge ( D.F -- G.D );	
	Str := edge ( D[10].F -- G.D[10] );
	Str := edge ( D.F[10] -- G[10].D );
	Str := edge ( D[10].F[10] -- G[10].D[10] );
	
	(*В дугах и ребрах диапазоны не допустимы*)
	$255,255
	Str := arc ( D[0:1].F[0:1] -- G.D );
	
	(*Индекс может задаваться переменной*)
	Str := arc ( D[a].F[a] -- G[a,a].D[a,a] );
	Str := edge ( D[a,a].F[a,a] -- G[a].D[a] );
	
	(*Тип индекса должен быть целым*)
	$155,155,155,155
	Str := arc ( D[1/2].F[1/2] -- G[1,1/2].D[1,1/2] );
	$155,155,155,155
	Str := edge ( D[1/2].F[1/2] -- G[1,1/2].D[1,1/2] );
	
	(*Если индекс задан константой, то она должна быть неотрицательной*)
	$169,169
	Str := arc ( D[0].F[0] -- G[0,-1].D[0,-1] );
	$169,169
	Str := edge ( D[0].F[0] -- G[0,-1].D[0,-1] );
	
	(*Графовые переменные*)
	structure g, h[10];
	
	Str := g;
	Str := h[0];
	Str := h[9];
	
	(*Выражение в скобках*)
	Str := (((g)));
	
	(*Структурные константы*)
	Str := star ( P );
	Str := dstar ( P );
	Str := cycle ( P );
	Str := dcycle ( P );
	Str := path ( P );
	Str := dpath ( P );
	
	Str := star ( P[10] );
	Str := star ( P[10]<L[10]> );
	Str := star ( P[10]<L[10],L[10]>, P[10]<L[10],L[10]> );
	Str := star ( P[0:10,10]<L[0],L[0:10,0]>, P[10]<L[10],L[10]> );
	
	(*Индекс может задаваться переменной*)
	Str := star ( P[a:a]<L[a:a]> );
	
	(*Тип индекса должен быть целым*)
	$155,155
	Str := star ( P[1/2]<L[1/2]> );
	
	(*Если индекс задан константой, то она должна быть положительной*)
	$169,169
	Str := star ( P[-1]<L[-1]>, P[0]<L[0]>, P[1]<L[1]> );
	
	(*Структурные операции*)
	Str := g + node P + arc ( A.A -- A.A ) + star( A );	
	Str := g - node P - arc ( A.A -- A.A ) - star( A );
	Str := arc ( A.A -- A.A ) - g - node P - star( A );
	Str := arc ( A.A -- A.A ) * g * node P * star( A );
	
	Str := ( arc ( A.A -- A.A ) + g + node P + star( A ) ) * edge ( A.A -- A.A );
	Str := ( arc ( A.A -- A.A ) - g - node P - star( A ) ) * edge ( A.A -- A.A );
	
	(*Диапазоны*)
	Str := node A[0:0]<P[0:0]>;
	
	(*Верхняя граница должна быть неотрицательна*)
	$169,169
	Str := node A[0:-1]<P[0:-1]>;
	
	(*Верхняя граница должна иметь целый тип*)
	$155,155
	Str := node A[0:""]<P[0:""]>;
		
	(*Недопустимо использование массивов*)
	array [10] of integer ar;
	$305,305
	Str := node A[0:ar]<P[0:ar]>;
	
	(*Верхняя граница не должна быть меньше нижней*)
	$320,320
	Str := node A[1:0]<P[1:0]>;
endstr